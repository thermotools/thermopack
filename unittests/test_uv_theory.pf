module test_uv_theory
  use hyperdual_mod
  use single_phase
  use uv_theory
  use eoslibinit, only: init_uv
  use thermopack_constants
  use thermopack_var, only: nc, nce, get_active_eos, base_eos_param, &
       thermo_model, get_active_thermo_model
  use pair_potentials, only: mie_potential_hd
  use pfunit_mod
  implicit none
  public

  ! VALUES FROM THE FEOS LIBRARY
  real, parameter :: SIGMA_CH4 = 3.7039e-10
  real, parameter :: EPSDIVK_CH4 = 150.03

  ! FEOS VALUES FOR BH-MIE
  real, parameter :: DHS_BH_12 = 0.95777257352360246
  real, parameter :: DHS_BH_24 = 0.95583586434435486
  real, parameter :: DELTA_A0_BH = -0.0611105573289734
  real, parameter :: DELTA_A1U_BH = -1.1470186919354
  real, parameter :: PHI_BH = 0.743451055308332
  real, parameter :: DELTA_B2U_BH = -0.949898568221715
  real, parameter :: DeltaB2_BH = -1.00533412744652
  real, parameter :: A_ATTR_BH = -1.16124062615291

  ! FEOS VALUES FOR WCA-MIE
  real, parameter :: Delta_A0_WCA = 0.258690311450425
  real, parameter :: QHS_WCA_24 = 0.9751576149023506
  real, parameter :: DHS_WCA_24 = 0.9614325601663462
  real, parameter :: DELTA_A1U_WCA = -1.52406840346272
  real, parameter :: DELTA_B2U_WCA = -1.02233215790525
  real, parameter :: PHI_WCA = 0.997069754340431
  real, parameter :: DELTAB2_WCA = -1.09102560732964
  real, parameter :: A_ATTR_WCA = -1.5242697155023
  real, parameter :: ARES_WCA_24 = 2.972986567516
  real, parameter :: ARES_BH_24 = 2.993577305779432

contains


  @Test
  subroutine test_B2_quadrature()
    use eostv, only: virial_coefficients
    use pair_potentials, only: calc_B2_by_quadrature
    type(hyperdual) :: T, B
    type(hyperdual) :: lamr, lama, sigma, epsdivk
    type(mie_potential_hd) :: mie

    ! Argon LJ parameters
    sigma = 3.42e-10
    epsdivk = 124.0
    lama = 6.0

    ! Mie(9,6)
    lamr = 9.0
    call mie%init(lama, lamr, sigma, epsdivk)

    T = 50.0
    B = mie%B2(beta=1.0/T)
    @assertEqual(-1.4433681332578888e-27, B%f0, 1e-6*abs(B%f0))

    T = 100.0
    B = mie%B2(beta=1.0/T)
    @assertEqual(-4.098406032480699e-28, B%f0, 1e-6*abs(B%f0))

    T = 300.0
    B = mie%B2(beta=1.0/T)
    @assertEqual(-5.844652795919477e-29, B%f0, 1e-6*abs(B%f0))


    ! Mie(12,6)
    lamr = 12.0
    call mie%init(lama, lamr, sigma, epsdivk)

    T = 50.0
    B = mie%B2(beta=1.0/T)
    @assertEqual(-1.1359200401456223e-27, B%f0, 1e-6*abs(B%f0))

    T = 100.0
    B = mie%B2(beta=1.0/T)
    @assertEqual(-3.0853860385426876e-28, B%f0, 1e-6*abs(B%f0))

    T = 300.0
    B = mie%B2(beta=1.0/T)
    @assertEqual(-2.960200932238359e-29, B%f0, 1e-6*abs(B%f0))


    ! Mie(24,6)
    lamr = 24.0
    call mie%init(lama, lamr, sigma, epsdivk)

    T = 50.0
    B = mie%B2(beta=1.0/T)
    @assertEqual(-7.240262820142041e-28, B%f0, 5e-6*abs(B%f0))

    T = 100.0
    B = mie%B2(beta=1.0/T)
    @assertEqual(-1.7958213544945865e-28, B%f0, 5e-6*abs(B%f0))

    T = 300.0
    B = mie%B2(beta=1.0/T)
    @assertEqual(7.410032208279907e-30, B%f0, 1e-4*abs(B%f0))

  end subroutine test_B2_quadrature



  !@Test
  subroutine test_vals_bh_mix()
    type(uv_theory_eos) :: eos
    real :: F
    integer :: nc = 2
    type(hyperdual) :: T, rho, z(2)
    type(hyperdual) :: lamr(2), lama(2), sigma(2), epsdivk(2)
    type(hyperdual) :: dhs, a_res, delta_a0, delta_a1u, delta_b2, delta_b2u, phi, a_attr
    type(mie_potential_hd) :: mie
    class(base_eos_param), pointer :: act_eos_ptr

    call init_uv(comps="AR,C1", model="uv-mie-wca",parameter_reference="DEFAULT")
    sigma = 1.0
    epsdivk = 1.0
    epsdivk(2) = 0.5
    lamr = 12.0
    lama = 6.0

    ! Test reference contribution (a0)
    rho = 0.9
    z = (/0.4, 0.6/)

    act_eos_ptr => get_active_eos()
    select type(p_eos => act_eos_ptr)
    type is (uv_theory_eos)
       print *, eos%mie(1,1)%lamr%f0
       call set_potential_parameters(eos,nc,lamr,sigma,epsdivk)

       T = 1.0/p_eos%epsdivk_x
       call preCalcUVTheory(p_eos,nc,T,z)

       ! Test attractive contributions (a-a0)
       call delta_a1u_b2u_Mie(p_eos, nc, T, rho, z, Delta_a1u, Delta_B2u)
       call phi_BH_Mie(T, rho, p_eos%mie(1,1), phi)
       call DeltaB2_Mie(p_eos,nc,T,z, Delta_B2)
       call calc_ares_uv(p_eos,nc,T,rhovec=rho*z, a_res=a_res)
       a_attr = Delta_a1u + (1.0-phi) * (Delta_B2 - Delta_B2u) * rho
       if (VERBOSE) then
          print *, "DELTA_B2_BH"
          print *, DeltaB2_BH
          print *, Delta_B2%f0

          print *, "DELTA_B2U_BH"
          print *, DELTA_B2U_BH
          print *, delta_b2u%f0

          print *, "DELTA_A1U_BH"
          print *, DELTA_A1U_BH
          print *, delta_a1u%f0

          print *, "PHI_BH"
          print *, PHI_BH
          print *, phi%f0

          print *, "A_ATTR_BH"
          print *, A_ATTR_BH
          print *, a_attr%f0

       end if
    end select
  end subroutine test_vals_bh_mix


  !@Test
  subroutine test_vals_bh()
    type(uv_theory_eos) :: eos
    real :: F
    type(hyperdual) :: T, rho, z(1)
    type(hyperdual) :: lamr, lama, sigma, epsdivk
    type(hyperdual) :: dhs, a_res, delta_a0, delta_a1u, delta_b2, delta_b2u, phi, a_attr
    type(mie_potential_hd) :: mie
    class(base_eos_param), pointer :: act_eos_ptr

    call init_uv(comps="AR", model="uv-mie-bh",parameter_reference="DEFAULT")
    sigma = 1.0
    epsdivk = 1.0
    lamr = 12.0
    lama = 6.0

    ! Test reference contribution (a0)
    act_eos_ptr => get_active_eos()
    select type(p_eos => act_eos_ptr)
    type is (uv_theory_eos)

       lamr = 24.0
       T = 5.0/epsdivk
       call mie%init(lama, lamr, sigma, epsdivk)
       call dhs_BH_Mie(T_r=T,mie=mie,dhs=dhs)
       if (VERBOSE) then
          print *, "DHS_BH_24"
          print *, DHS_BH_24
          print *, dhs%f0
       end if
       @assertEqual(DHS_BH_24, dhs%f0, 1e-10*DHS_BH_24)

       lamr = 12.0
       T = 2.0/epsdivk
       call mie%init(lama, lamr, sigma, epsdivk)
       call dhs_BH_Mie(T_r=T,mie=mie,dhs=dhs)
       if (VERBOSE) then
          print *, "DHS_BH_12"
          print *, DHS_BH_12
          print *, dhs%f0
       end if
       @assertEqual(DHS_BH_12, dhs%f0, 1e-10*DHS_BH_24)

       lamr = 24.0
       T = 4.0/epsdivk
       z(1) = 1.0
       rho = 1.0
       call p_eos%mie(1,1)%init(lama, lamr, sigma, epsdivk)
       call preCalcUVTheory(p_eos,nc,T,z)
       call Delta_a0_Mie(p_eos, nc, T, rho, z, delta_a0)
       if (VERBOSE) then
          print *, "DELTA_A0_BH"
          print *, DELTA_A0_BH
          print *, delta_a0%f0
       end if
       @assertEqual(DELTA_A0_BH, delta_a0%f0, 1e-8*abs(DELTA_A0_BH))

       ! Test attractive contributions (a-a0)
       lamr = 24.0
       T = 4.0/epsdivk
       z(1) = 1.0
       rho = 1.0
       call p_eos%mie(1,1)%init(lama, lamr, sigma, epsdivk)
       call preCalcUVTheory(p_eos,nc,T,z)
       call delta_a1u_b2u_Mie(p_eos, nc, T, rho, z, Delta_a1u, Delta_B2u)
       call phi_BH_Mie(T, rho, p_eos%mie(1,1), phi)
       call DeltaB2_Mie(p_eos,nc,T,z, Delta_B2)
       call calc_ares_uv(p_eos,nc,T,rhovec=rho*z, a_res=a_res)
       a_attr = Delta_a1u + (1.0-phi) * (Delta_B2 - Delta_B2u) * rho
       if (VERBOSE) then
          print *, "DELTA_B2_BH"
          print *, DeltaB2_BH
          print *, Delta_B2%f0

          print *, "DELTA_B2U_BH"
          print *, DELTA_B2U_BH
          print *, delta_b2u%f0

          print *, "DELTA_A1U_BH"
          print *, DELTA_A1U_BH
          print *, delta_a1u%f0

          print *, "PHI_BH"
          print *, PHI_BH
          print *, phi%f0

          print *, "A_ATTR_BH"
          print *, A_ATTR_BH
          print *, a_attr%f0

       end if
       @assertEqual(DeltaB2_BH, Delta_B2%f0, 1e-8*abs(DeltaB2_BH))
       @assertEqual(DELTA_B2U_BH, delta_b2u%f0, 1e-8*abs(DELTA_B2U_BH))
       @assertEqual(DELTA_A1U_BH, delta_a1u%f0, 1e-8*abs(DELTA_A1U_BH))
       @assertEqual(PHI_BH, phi%f0, 1e-5*abs(PHI_BH))
       @assertEqual(A_ATTR_BH, a_attr%f0, 1e-8*abs(A_ATTR_BH))

       ! Test full Ares/NkT with realistic potential
       lamr = 24.0
       epsdivk = EPSDIVK_CH4
       sigma = 1.0*SIGMA_CH4
       T = 4.0*epsdivk
       z(1) = 1.0
       rho = 1.0/(sigma**3)
       call p_eos%mie(1,1)%init(lama, lamr, sigma, epsdivk)
       call calc_ares_uv(p_eos,nc,T,rhovec=rho*z, a_res=a_res)
       if (VERBOSE) then
          print *, "ARES_BH_24"
          print *, ARES_BH_24
          print *, a_res%f0
       end if
       @assertEqual(ARES_BH_24, a_res%f0, 1e-8*abs(ARES_BH_24))

    end select
    lamr = 12.0

  end subroutine test_vals_bh


  !@Test
  subroutine test_vals_wca()
    type(uv_theory_eos) :: eos
    real :: F
    type(hyperdual) :: T, rho, z(1)
    type(hyperdual) :: lamr, lama, sigma, epsdivk
    type(hyperdual) :: dhs, qhs, a_res, delta_a0, delta_a1u, delta_b2, delta_b2u, phi, a_attr
    type(mie_potential_hd) :: mie
    class(base_eos_param), pointer :: act_eos_ptr

    call init_uv(comps="AR", model="uv-mie-wca",parameter_reference="DEFAULT")
    sigma = 1.0
    epsdivk = 1.0
    lamr = 12.0
    lama = 6.0

    ! Test reference contribution (a0)
    act_eos_ptr => get_active_eos()
    select type(p_eos => act_eos_ptr)
    type is (uv_theory_eos)

       lamr = 24.0
       T = 4.0/epsdivk
       call mie%init(lama, lamr, sigma, epsdivk)
       call dhs_WCA_Mie(T_r=T,mie=mie,dhs=dhs)
       call qhs_WCA_Mie(T_r=T,mie=mie,qhs=qhs)
       if (VERBOSE) then
          print *, "DHS_WCA_24"
          print *, DHS_WCA_24
          print *, dhs%f0

          print *, "QHS_WCA_24"
          print *, QHS_WCA_24
          print *, qhs%f0

       end if
       @assertEqual(DHS_WCA_24, dhs%f0, 1e-10*DHS_WCA_24)

       lamr = 24.0
       T = 4.0/epsdivk
       z(1) = 1.0
       rho = 1.0
       call p_eos%mie(1,1)%init(lama, lamr, sigma, epsdivk)
       call preCalcUVTheory(p_eos,nc,T,z)
       call Delta_a0_Mie(p_eos, nc, T, rho, z, delta_a0)
       if (VERBOSE) then
          print *, "DELTA_A0_WCA"
          print *, DELTA_A0_WCA
          print *, delta_a0%f0
       end if
       @assertEqual(DELTA_A0_WCA, delta_a0%f0, 1e-8*abs(DELTA_A0_WCA))


       ! Test attractive contributions (a-a0)
       lamr = 24.0
       T = 4.0/epsdivk
       z(1) = 1.0
       rho = 1.0
       call p_eos%mie(1,1)%init(lama, lamr, sigma, epsdivk)
       call preCalcUVTheory(p_eos,nc,T,z)
       call delta_a1u_b2u_Mie(p_eos, nc, T, rho, z, Delta_a1u, Delta_B2u)
       call phi_WCA_Mie(rho, p_eos%mie(1,1)%lamr, phi)
       call DeltaB2_Mie(p_eos,nc,T,z, Delta_B2)
       call calc_ares_uv(p_eos,nc,T,rho*z, a_res)

       a_attr = Delta_a1u + (1.0-phi) * (Delta_B2 - Delta_B2u) * rho
       if (VERBOSE) then
          print *, "DELTA_B2_WCA"
          print *, DeltaB2_WCA
          print *, Delta_B2%f0

          print *, "DELTA_B2U_WCA"
          print *, DELTA_B2U_WCA
          print *, delta_b2u%f0

          print *, "DELTA_A1U_WCA"
          print *, DELTA_A1U_WCA
          print *, delta_a1u%f0

          print *, "PHI_WCA"
          print *, PHI_WCA
          print *, phi%f0

          print *, "A_ATTR_WCA"
          print *, A_ATTR_WCA
          print *, a_attr%f0

       end if
       @assertEqual(DeltaB2_WCA, Delta_B2%f0, 1e-8*abs(DeltaB2_WCA))
       @assertEqual(DELTA_B2U_WCA, delta_b2u%f0, 1e-8*abs(DELTA_B2U_WCA))
       @assertEqual(DELTA_A1U_WCA, delta_a1u%f0, 1e-8*abs(DELTA_A1U_WCA))
       @assertEqual(PHI_WCA, phi%f0, 1e-7*abs(PHI_WCA))
       @assertEqual(A_ATTR_WCA, a_attr%f0, 1e-7*abs(A_ATTR_WCA))

       ! Test full Ares/NkT with realistic potential
       lamr = 24.0
       epsdivk = EPSDIVK_CH4
       sigma = 1.0*SIGMA_CH4
       T = 4.0*epsdivk
       z(1) = 1.0
       rho = 1.0/(sigma**3)
       call p_eos%mie(1,1)%init(lama, lamr, sigma, epsdivk)
       call calc_ares_uv(p_eos,nc,T,rhovec=rho*z, a_res=a_res)
       if (VERBOSE) then
          print *, "ARES_WCA_24"
          print *, ARES_WCA_24
          print *, a_res%f0
       end if
       @assertEqual(ARES_WCA_24, a_res%f0, 1e-10*abs(ARES_WCA_24))

    end select

  end subroutine test_vals_wca


  !@Test
  subroutine test_derivs()
    integer, parameter :: nc = 1
    real :: P, T, n(nc), v, rho
    real :: F,F_T,F_V,F_n(nc), F_VVV
    real :: F_TT,F_TV,F_Tn(nc),F_VV,F_Vn(nc),F_nn(nc,nc)
    real :: pF,pF_T,pF_V,pF_n(nc), pF_VVV
    real :: pF_TT,pF_TV,pF_Tn(nc),pF_VV,pF_Vn(nc),pF_nn(nc,nc)
    real :: mF,mF_T,mF_V,mF_n(nc), mF_VVV
    real :: mF_TT,mF_TV,mF_Tn(nc),mF_VV,mF_Vn(nc),mF_nn(nc,nc)

    real, parameter :: EPS = 1E-6
    real :: npert(nc)
    real :: Teps, Veps, Neps

    integer :: i, j
    class(base_eos_param), pointer :: cbeos
    class(thermo_model), pointer :: act_mod_ptr

    ! Define state
    T=100; rho=3e4
    n = (/1.0/)

    rho = 3.4
    T = 100
    n = (/1.5/)
    V = n(1)/rho

    ! Test state points
    call init_uv(comps="AR", model="uv-mie-wca",parameter_reference="DEFAULT")

    ! Test numerical derivatives
    cbeos => get_active_eos()
    act_mod_ptr => get_active_thermo_model()
    call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T,V,n,F,F_T,F_V,F_n,F_TT, F_TV,F_VV,F_Tn,F_Vn,F_nn,recalculate=.True.)
    print *, "calcfres", F
    ! T derivatives
    Teps = T*EPS
    call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T+Teps,V,n,&
         pF,pF_T,pF_V,pF_n,pF_TT, pF_TV,pF_VV,pF_Tn,pF_Vn,pF_nn,recalculate=.True.)
    call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T-Teps,V,n,&
         mF,mF_T,mF_V,mF_n,mF_TT, mF_TV,mF_VV,mF_Tn,mF_Vn,mF_nn,recalculate=.True.)
    if (VERBOSE) then
       print *, "F_t"
       print *, (pF-mF)/(2*Teps)
       print *, F_t

       print *, "F_tt"
       print *, (pF_t-mF_t)/(2*Teps)
       print *, F_tt

       print *, "F_tv"
       print *, (pF_v-mF_v)/(2*Teps)
       print *, F_tv
    end if
    @assertTrue(abs(F_tv - (pF_v-mF_v)/(2*Teps)) < (1e-7*abs(F_tv)+1e-15))
    @assertTrue(abs(F_tt - (pF_t-mF_t)/(2*Teps)) < (1e-7*abs(F_tt)+1e-15))
    @assertTrue(abs(F_t - (pF-mF)/(2*Teps)) < (1e-7*abs(F_t)+1e-15))

    ! V derivatives
    Veps = V*EPS
    call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T,V+Veps,n,&
         pF,pF_T,pF_V,pF_n,pF_TT, pF_TV,pF_VV,pF_Tn,pF_Vn,pF_nn,recalculate=.True.)
    call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T,V-Veps,n,&
         mF,mF_T,mF_V,mF_n,mF_TT, mF_TV,mF_VV,mF_Tn,mF_Vn,mF_nn,recalculate=.True.)
    if (VERBOSE) then
       print *, "F_V"
       print *, (pF-mF)/(2*Veps)
       print *, F_V

       print *, "F_VV"
       print *, (pF_V-mF_V)/(2*Veps)
       print *, F_VV

    end if
    @assertTrue(abs(F_V - (pF-mF)/(2*Veps)) < (1e-5*abs(F_V)+1e-15))
    @assertTrue(abs(F_VV - (pF_V-mF_V)/(2*Veps)) < (1e-5*abs(F_VV)+1e-15))

    ! n derivatives
    neps = EPS
    do i=1,nc
       npert = n
       npert(i) = n(i)+neps
       call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T,V,npert,pF,pF_T,pF_V,pF_n,&
            pF_TT, pF_TV,pF_VV,pF_Tn,pF_Vn,pF_nn,recalculate=.True.)
       npert(i) = n(i)-neps
       call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T,V,npert,mF,mF_T,mF_V,mF_n,&
            mF_TT, mF_TV,mF_VV,mF_Tn,mF_Vn,mF_nn,recalculate=.True.)

       j = nc+1-i
       if (VERBOSE) then
          print *, "F_Tn"
          print *, (pF_T-mF_T)/(2*neps)
          print *, F_Tn(i)

          print *, "F_Vn"
          print *, (pF_V-mF_V)/(2*neps)
          print *, F_Vn(i)

          print *, "F_n"
          print *, (pF-mF)/(2*neps)
          print *, F_n(i)

          print *, "F_nn like"
          print *, (pF_n(i)-mF_n(i))/(2*neps)
          print *, F_nn(i,i)

          print *, "F_nn cross"
          print *, (pF_n(j)-mF_n(j))/(2*neps)
          print *, F_nn(i,j)
          print *, F_nn(j,i)
       end if

       @assertTrue(abs(F_Vn(i) - (pF_V-mF_V)/(2*neps)) < (1e-5*abs(F_Vn(i))+1e-15))
       @assertTrue(abs(F_Tn(i) - (pF_T-mF_T)/(2*neps)) < (1e-7*abs(F_Tn(i))+1e-15))
       @assertTrue(abs(F_n(i) - (pF-mF)/(2*neps)) < (1e-6*abs(F_n(i))+1e-15))
       @assertTrue(abs(F_nn(i,j) - (pF_n(j)-mF_n(j))/(2*neps)) < (1e-5*abs(F_nn(i,j))+1e-15))
    end do

  end subroutine test_derivs

end module test_uv_theory
