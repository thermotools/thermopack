module test_uv_theory
  use hyperdual_mod
  use single_phase
  use uv_theory!, only: calcFres_uv, uv_theory_eos, dhs_BH_Mie
  use eoslibinit, only: init_thermo, init_saftvrmie, init_uv
  use thermopack_constants
  use critical, only: calcCriticalTV
  use eosTV, only: pressure, free_energy_tv
  use saft_interface, only: calcSaftFder_res_nonassoc
  use saftvrmie_dispersion, only: calcA1
  use thermopack_var, only: nc, nce, get_active_eos, base_eos_param, &
       thermo_model, get_active_thermo_model
  use pair_potentials, only: mie_potential_hd
  use pfunit_mod
  implicit none
  public

  real, parameter :: SIGMA_CH4 = 3.7039e-10
  real, parameter :: EPSDIVK_CH4 = 150.03

  ! The following values are from the feos library
  real, parameter :: DHS_BH_12 = 0.95777257352360246
  real, parameter :: DHS_BH_24 = 0.95583586434435486
  real, parameter :: DELTA_A0_BH = -0.0611105573289734

  real, parameter :: DELTA_A1U_BH = -1.1470186919354
  real, parameter :: PHI_BH = 0.743451055308332
  real, parameter :: DELTA_B2U_BH = -0.949898568221715

  real, parameter :: DeltaB2_BH = -1.00533412744652
  real, parameter :: A_ATTR_BH = -1.16124062615291

  ! FEOS VALUES FOR WCA-MIE
  real, parameter :: Delta_A0_WCA = 0.258690311450425
  real, parameter :: QHS_WCA_24 = 0.9751576149023506
  real, parameter :: DHS_WCA_24 = 0.9614325601663462
  
  real, parameter :: DELTA_A1U_WCA = -1.52406840346272
  real, parameter :: DELTA_B2U_WCA = -1.02233215790525
  real, parameter :: PHI_WCA = 0.997069754340431

  real, parameter :: DELTAB2_WCA = -1.09102560732964
  real, parameter :: A_ATTR_WCA = -1.5242697155023


contains

  !@Test
  subroutine test_vals_bh()
    type(uv_theory_eos) :: eos
    real :: F
    type(hyperdual) :: T, rho, z(1)
    type(hyperdual) :: lamr, lama, sigma, epsdivk
    type(hyperdual) :: dhs, a, delta_a0, delta_a1u, delta_b2, delta_b2u, phi, a_attr
    type(mie_potential_hd) :: mie
    class(base_eos_param), pointer :: act_eos_ptr
    
    VERBOSE = .TRUE.
    
    ! Test BH diameter
    call init_uv(model="uv-mie-bh",parameter_reference="DEFAULT")
    ! call calcFres_uv(p_eos,nc,T,V,z, F)
    print *, "test_vals_bh"

    sigma = 1.0
    epsdivk = 1.0
    lamr = 12.0
    lama = 6.0

    ! Test reference contribution (a0)
    act_eos_ptr => get_active_eos()
    select type(p_eos => act_eos_ptr)
    type is (uv_theory_eos)

       lamr = 24.0
       T = 5.0/epsdivk
       call mie%init(lama, lamr, sigma, epsdivk)
       call dhs_BH_Mie(T_r=T,mie=mie,dhs=dhs)
       if (VERBOSE) then
          print *, "DHS_BH_24"
          print *, DHS_BH_24
          print *, dhs%f0
       end if
       @assertEqual(DHS_BH_24, dhs%f0, 1e-10*DHS_BH_24)

       lamr = 12.0
       T = 2.0/epsdivk
       call mie%init(lama, lamr, sigma, epsdivk)
       call dhs_BH_Mie(T_r=T,mie=mie,dhs=dhs)
       if (VERBOSE) then
          print *, "DHS_BH_12"
          print *, DHS_BH_12
          print *, dhs%f0
       end if
       @assertEqual(DHS_BH_12, dhs%f0, 1e-10*DHS_BH_24)

       lamr = 24.0
       T = 4.0/epsdivk
       z(1) = 1.0
       rho = 1.0
       call p_eos%mie(1,1)%init(lama, lamr, sigma, epsdivk)
       call preCalcUVTheory(p_eos,nc,T,z)
       call Delta_a0_Mie(p_eos, nc, T, rho, z, delta_a0)
       if (VERBOSE) then
          print *, "DELTA_A0_BH"
          print *, DELTA_A0_BH
          print *, delta_a0%f0
       end if
       @assertEqual(DELTA_A0_BH, delta_a0%f0, 1e-8*abs(DELTA_A0_BH))


       ! Test attractive contributions (a-a0)
       lamr = 24.0
       T = 4.0/epsdivk
       z(1) = 1.0
       rho = 1.0
       call p_eos%mie(1,1)%init(lama, lamr, sigma, epsdivk)
       call preCalcUVTheory(p_eos,nc,T,z)
       call delta_a1u_b2u_Mie(p_eos, nc, T, rho, z, Delta_a1u, Delta_B2u)
       call phi_BH_Mie(T, rho, p_eos%mie(1,1), phi)
       call DeltaB2_Mie(p_eos,nc,T,z, Delta_B2)
       a_attr = Delta_a1u + (1.0-phi) * (Delta_B2 - Delta_B2u) * rho
       if (VERBOSE) then
          print *, "DELTA_B2_BH"
          print *, DeltaB2_BH
          print *, Delta_B2%f0

          print *, "DELTA_B2U_BH"
          print *, DELTA_B2U_BH
          print *, delta_b2u%f0

          print *, "DELTA_A1U_BH"
          print *, DELTA_A1U_BH
          print *, delta_a1u%f0

          print *, "PHI_BH"
          print *, PHI_BH
          print *, phi%f0


          print *, "A_ATTR_BH"
          print *, A_ATTR_BH
          print *, a_attr%f0
       end if
       @assertEqual(DeltaB2_BH, Delta_B2%f0, 1e-8*abs(DeltaB2_BH))
       @assertEqual(DELTA_B2U_BH, delta_b2u%f0, 1e-8*abs(DELTA_B2U_BH))
       @assertEqual(DELTA_A1U_BH, delta_a1u%f0, 1e-8*abs(DELTA_A1U_BH))
       @assertEqual(PHI_BH, phi%f0, 1e-5*abs(PHI_BH))
       @assertEqual(A_ATTR_BH, a_attr%f0, 1e-8*abs(A_ATTR_BH))
       
    end select
    lamr = 12.0

  end subroutine test_vals_bh


  @Test
  subroutine test_vals_wca()
    type(uv_theory_eos) :: eos
    real :: F
    type(hyperdual) :: T, rho, z(1)
    type(hyperdual) :: lamr, lama, sigma, epsdivk
    type(hyperdual) :: dhs, qhs, a, delta_a0, delta_a1u, delta_b2, delta_b2u, phi, a_attr
    type(mie_potential_hd) :: mie
    class(base_eos_param), pointer :: act_eos_ptr
    
    VERBOSE = .TRUE.
    
    ! Test WCA diameter
    call init_uv(model="uv-mie-wca",parameter_reference="DEFAULT")
    ! call calcFres_uv(p_eos,nc,T,V,z, F)
    print *, "test_vals_wca"

    sigma = 1.0
    epsdivk = 1.0
    lamr = 12.0
    lama = 6.0

    ! Test reference contribution (a0)
    act_eos_ptr => get_active_eos()
    select type(p_eos => act_eos_ptr)
    type is (uv_theory_eos)

       lamr = 24.0
       T = 4.0/epsdivk
       call mie%init(lama, lamr, sigma, epsdivk)
       call dhs_WCA_Mie(T_r=T,mie=mie,dhs=dhs)
       call qhs_WCA_Mie(T_r=T,mie=mie,qhs=qhs)
       if (VERBOSE) then
          print *, "DHS_WCA_24"
          print *, DHS_WCA_24
          print *, dhs%f0

          print *, "QHS_WCA_24"
          print *, QHS_WCA_24
          print *, qhs%f0

       end if
       @assertEqual(DHS_WCA_24, dhs%f0, 1e-10*DHS_WCA_24)

       lamr = 24.0
       T = 4.0/epsdivk
       z(1) = 1.0
       rho = 1.0
       call p_eos%mie(1,1)%init(lama, lamr, sigma, epsdivk)
       call preCalcUVTheory(p_eos,nc,T,z)
       call Delta_a0_Mie(p_eos, nc, T, rho, z, delta_a0)
       if (VERBOSE) then
          print *, "DELTA_A0_WCA"
          print *, DELTA_A0_WCA
          print *, delta_a0%f0
       end if
       @assertEqual(DELTA_A0_WCA, delta_a0%f0, 1e-8*abs(DELTA_A0_WCA))


       ! Test attractive contributions (a-a0)
       lamr = 24.0
       T = 4.0/epsdivk
       z(1) = 1.0
       rho = 1.0
       call p_eos%mie(1,1)%init(lama, lamr, sigma, epsdivk)
       call preCalcUVTheory(p_eos,nc,T,z)
       call delta_a1u_b2u_Mie(p_eos, nc, T, rho, z, Delta_a1u, Delta_B2u)
       call phi_WCA_Mie(rho, p_eos%mie(1,1)%lamr, phi)
       call DeltaB2_Mie(p_eos,nc,T,z, Delta_B2)
       a_attr = Delta_a1u + (1.0-phi) * (Delta_B2 - Delta_B2u) * rho
       if (VERBOSE) then
          print *, "DELTA_B2_WCA"
          print *, DeltaB2_WCA
          print *, Delta_B2%f0

          print *, "DELTA_B2U_WCA"
          print *, DELTA_B2U_WCA
          print *, delta_b2u%f0

          print *, "DELTA_A1U_WCA"
          print *, DELTA_A1U_WCA
          print *, delta_a1u%f0

          print *, "PHI_WCA"
          print *, PHI_WCA
          print *, phi%f0


          print *, "A_ATTR_WCA"
          print *, A_ATTR_WCA
          print *, a_attr%f0
       end if
       @assertEqual(DeltaB2_WCA, Delta_B2%f0, 1e-8*abs(DeltaB2_WCA))
       @assertEqual(DELTA_B2U_WCA, delta_b2u%f0, 1e-8*abs(DELTA_B2U_WCA))
       @assertEqual(DELTA_A1U_WCA, delta_a1u%f0, 1e-8*abs(DELTA_A1U_WCA))
       @assertEqual(PHI_WCA, phi%f0, 1e-5*abs(PHI_WCA))
       @assertEqual(A_ATTR_WCA, a_attr%f0, 1e-7*abs(A_ATTR_WCA))
       
    end select
    lamr = 12.0

  end subroutine test_vals_wca

  
  !@Test
  subroutine test_derivs()
    integer, parameter :: nc = 1
    real :: P, T, n(nc), v, rho
    real :: F,F_T,F_V,F_n(nc), F_VVV
    real :: F_TT,F_TV,F_Tn(nc),F_VV,F_Vn(nc),F_nn(nc,nc)
    real :: pF,pF_T,pF_V,pF_n(nc), pF_VVV
    real :: pF_TT,pF_TV,pF_Tn(nc),pF_VV,pF_Vn(nc),pF_nn(nc,nc)
    real :: mF,mF_T,mF_V,mF_n(nc), mF_VVV
    real :: mF_TT,mF_TV,mF_Tn(nc),mF_VV,mF_Vn(nc),mF_nn(nc,nc)

    real, parameter :: EPS = 1E-6
    real :: npert(nc)
    real :: Teps, Veps, Neps

    integer :: i, j
    class(base_eos_param), pointer :: cbeos
    class(thermo_model), pointer :: act_mod_ptr

    ! Define state
    T=100; rho=3e4
    n = (/1.0/)

    rho = 3.4
    T = 100
    n = (/1.5/)
    V = n(1)/rho

    ! Test state points
    call init_uv(model="WCA",parameter_reference="DEFAULT")
    call free_energy_tv(T,V,n,F)
    !print *, "y", F
    !call specificVolume(T,P,n,VAPPH,V)

    ! Test numerical derivatives
    cbeos => get_active_eos()
    act_mod_ptr => get_active_thermo_model()
    !call specificVolume(T,P,n,VAPPH,V)
    call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T,V,n,F,F_T,F_V,F_n,F_TT, F_TV,F_VV,F_Tn,F_Vn,F_nn,recalculate=.True.)
    print *, "calcfres", F
    ! T derivatives
    Teps = T*EPS
    call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T+Teps,V,n,&
         pF,pF_T,pF_V,pF_n,pF_TT, pF_TV,pF_VV,pF_Tn,pF_Vn,pF_nn,recalculate=.True.)
    call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T-Teps,V,n,&
         mF,mF_T,mF_V,mF_n,mF_TT, mF_TV,mF_VV,mF_Tn,mF_Vn,mF_nn,recalculate=.True.)
    if (VERBOSE) then
       print *, "F_t"
       print *, (pF-mF)/(2*Teps)
       print *, F_t

       print *, "F_tt"
       print *, (pF_t-mF_t)/(2*Teps)
       print *, F_tt

       print *, "F_tv"
       print *, (pF_v-mF_v)/(2*Teps)
       print *, F_tv
    end if
    @assertTrue(abs(F_tv - (pF_v-mF_v)/(2*Teps)) < (1e-7*abs(F_tv)+1e-15))
    @assertTrue(abs(F_tt - (pF_t-mF_t)/(2*Teps)) < (1e-7*abs(F_tt)+1e-15))
    @assertTrue(abs(F_t - (pF-mF)/(2*Teps)) < (1e-7*abs(F_t)+1e-15))

    ! V derivatives
    Veps = V*EPS
    call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T,V+Veps,n,&
         pF,pF_T,pF_V,pF_n,pF_TT, pF_TV,pF_VV,pF_Tn,pF_Vn,pF_nn,recalculate=.True.)
    call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T,V-Veps,n,&
         mF,mF_T,mF_V,mF_n,mF_TT, mF_TV,mF_VV,mF_Tn,mF_Vn,mF_nn,recalculate=.True.)
    if (VERBOSE) then
       print *, "F_V"
       print *, (pF-mF)/(2*Veps)
       print *, F_V

       print *, "F_VV"
       print *, (pF_V-mF_V)/(2*Veps)
       print *, F_VV

    end if
    @assertTrue(abs(F_V - (pF-mF)/(2*Veps)) < (1e-5*abs(F_V)+1e-15))
    @assertTrue(abs(F_VV - (pF_V-mF_V)/(2*Veps)) < (1e-5*abs(F_VV)+1e-15))

    ! n derivatives
    neps = EPS
    do i=1,nc
       npert = n
       npert(i) = n(i)+neps
       call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T,V,npert,pF,pF_T,pF_V,pF_n,&
            pF_TT, pF_TV,pF_VV,pF_Tn,pF_Vn,pF_nn,recalculate=.True.)
       npert(i) = n(i)-neps
       call TV_CalcFres(nc,act_mod_ptr%comps,cbeos,T,V,npert,mF,mF_T,mF_V,mF_n,&
            mF_TT, mF_TV,mF_VV,mF_Tn,mF_Vn,mF_nn,recalculate=.True.)

       j = nc+1-i
       if (VERBOSE) then
          print *, "F_Tn"
          print *, (pF_T-mF_T)/(2*neps)
          print *, F_Tn(i)

          print *, "F_Vn"
          print *, (pF_V-mF_V)/(2*neps)
          print *, F_Vn(i)

          print *, "F_n"
          print *, (pF-mF)/(2*neps)
          print *, F_n(i)

          print *, "F_nn like"
          print *, (pF_n(i)-mF_n(i))/(2*neps)
          print *, F_nn(i,i)

          print *, "F_nn cross"
          print *, (pF_n(j)-mF_n(j))/(2*neps)
          print *, F_nn(i,j)
          print *, F_nn(j,i)
       end if

       @assertTrue(abs(F_Vn(i) - (pF_V-mF_V)/(2*neps)) < (1e-5*abs(F_Vn(i))+1e-15))
       @assertTrue(abs(F_Tn(i) - (pF_T-mF_T)/(2*neps)) < (1e-7*abs(F_Tn(i))+1e-15))
       @assertTrue(abs(F_n(i) - (pF-mF)/(2*neps)) < (1e-6*abs(F_n(i))+1e-15))
       @assertTrue(abs(F_nn(i,j) - (pF_n(j)-mF_n(j))/(2*neps)) < (1e-5*abs(F_nn(i,j))+1e-15))
    end do

  end subroutine test_derivs

end module test_uv_theory
